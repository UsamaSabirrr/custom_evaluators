{
  "evaluator": {
    "func": "exact_match",
    "postconfig": [
      {
        "type": "sleep",
        "parameters": {
          "seconds": 2
        }
      }
    ],
    "result": {
      "type": "vm_command_line",
      "command": [
        "bash",
        "-c",
        "python3 - <<'EOF'\nimport sys\nimport hashlib\nimport xml.etree.ElementTree as ET\nfrom pathlib import Path\n\nACTUAL_FILE_PATH = '/home/user/actual_presentation.pptx'\nGOLDEN_FILE_PATH = '/tmp/golden_presentation.pptx'\n\ntry:\n    from pptx import Presentation\n    from pptx.enum.shapes import MSO_SHAPE_TYPE\n    from pptx.enum.text import PP_ALIGN\n    from pptx.enum.dml import MSO_FILL_TYPE\nexcept ImportError:\n    print('ERROR: python-pptx library not found!', end='')\n    sys.exit(0)\n\nif not Path(ACTUAL_FILE_PATH).exists():\n    print('ERROR: Actual file not found', end='')\n    sys.exit(0)\n\nif not Path(GOLDEN_FILE_PATH).exists():\n    print('ERROR: Golden file not found', end='')\n    sys.exit(0)\n\nTEXT_SHAPE_TYPES = {\n    MSO_SHAPE_TYPE.TEXT_BOX,\n    MSO_SHAPE_TYPE.AUTO_SHAPE,\n    MSO_SHAPE_TYPE.PLACEHOLDER,\n}\n\nfirst_mismatch = None\n\ndef log_mismatch(message):\n    global first_mismatch\n    if first_mismatch is None:\n        first_mismatch = message\n\ndef get_all_text_shapes(slide):\n    text_shapes = []\n    def _extract_from_shape(shape):\n        if hasattr(shape, 'text_frame'):\n            text_shapes.append(shape)\n        if shape.shape_type == MSO_SHAPE_TYPE.GROUP:\n            for child_shape in shape.shapes:\n                _extract_from_shape(child_shape)\n    for shape in slide.shapes:\n        _extract_from_shape(shape)\n    return text_shapes\n\ndef is_approximately_equal(val1, val2, tolerance=0.005):\n    if val1 == val2:\n        return True\n    if val1 == 0 and val2 == 0:\n        return True\n    abs_diff = abs(val1 - val2)\n    if abs_diff <= 1000:\n        return True\n    if val1 == 0 or val2 == 0:\n        return False\n    percentage_diff = abs_diff / max(abs(val1), abs(val2))\n    return percentage_diff <= tolerance\n\ndef normalize_alignment(alignment):\n    return PP_ALIGN.LEFT if alignment is None else alignment\n\ndef normalize_cell_text(text):\n    import re\n    return re.sub(r'\\s+', ' ', text).strip()\n\ndef get_slide_background_color(slide):\n    fill = slide.background.fill\n    if fill.type == 1:\n        return fill.fore_color.rgb\n    elif fill.type == 5:\n        master_fill = slide.slide_layout.slide_master.background.fill\n        if master_fill.type == 1:\n            return master_fill.fore_color.rgb\n    return None\n\ndef get_slide_notes(slide):\n    notes_slide = slide.notes_slide\n    if notes_slide:\n        return notes_slide.notes_text_frame.text\n    return \"\"\n\ndef extract_bullets(xml_data):\n    root = ET.fromstring(xml_data)\n    namespaces = {\n        'a': 'http://schemas.openxmlformats.org/drawingml/2006/main',\n        'p': 'http://schemas.openxmlformats.org/presentationml/2006/main',\n    }\n    bullets = []\n    for paragraph in root.findall('.//a:p', namespaces):\n        pPr = paragraph.find('a:pPr', namespaces)\n        if pPr is not None:\n            lvl = pPr.get('lvl')\n            buChar = pPr.find('a:buChar', namespaces)\n            char = buChar.get('char') if buChar is not None else \"No Bullet\"\n            buClr = pPr.find('a:buClr/a:srgbClr', namespaces)\n            color = buClr.get('val') if buClr is not None else \"No Color\"\n        else:\n            lvl = \"No Level\"\n            char = \"No Bullet\"\n            color = \"No Color\"\n        text = \"\".join(t.text for t in paragraph.findall('.//a:t', namespaces))\n        if text.strip():\n            bullets.append((lvl, char, text, color))\n    return bullets\n\ndef compare_bullets(bullets1, bullets2):\n    if len(bullets1) != len(bullets2):\n        return False\n    for (lvl1, char1, text1, _), (lvl2, char2, text2, _) in zip(bullets1, bullets2):\n        if text1 != text2 or char1 != char2:\n            return False\n        if ('0' if lvl1 is None else lvl1) != ('0' if lvl2 is None else lvl2):\n            return False\n    return True\n\ndef fonts_effectively_equal(val1, val2, treat_none_as_false=True):\n    if val1 == val2:\n        return True\n    if treat_none_as_false:\n        return (val1 is None or val1 is False) and (val2 is None or val2 is False)\n    return False\n\ndef get_shape_signature(shape):\n    shape_type = shape.shape_type\n    text_content = \"\"\n    image_hash = \"\"\n    if hasattr(shape, 'text'):\n        text_content = shape.text.strip()\n    if shape_type == MSO_SHAPE_TYPE.PICTURE:\n        try:\n            image_hash = hashlib.md5(shape.image.blob).hexdigest()\n        except Exception:\n            pass\n    if shape_type == MSO_SHAPE_TYPE.TABLE:\n        try:\n            table_text = []\n            for row_idx in range(len(shape.table.rows)):\n                for col_idx in range(len(shape.table.columns)):\n                    cell_text = normalize_cell_text(shape.table.cell(row_idx, col_idx).text)\n                    if cell_text:\n                        table_text.append(cell_text)\n            text_content = \"|\".join(table_text)\n        except Exception:\n            pass\n    return (shape_type, text_content, image_hash)\n\ndef find_matching_shape(target_shape, candidate_shapes, used_indices):\n    target_sig = get_shape_signature(target_shape)\n    target_type, target_text, target_hash = target_sig\n    best_match = None\n    best_match_idx = -1\n    best_score = -1\n    for idx, candidate in enumerate(candidate_shapes):\n        if idx in used_indices:\n            continue\n        cand_sig = get_shape_signature(candidate)\n        cand_type, cand_text, cand_hash = cand_sig\n        score = 0\n        if target_type == cand_type:\n            score += 10\n        elif target_type in TEXT_SHAPE_TYPES and cand_type in TEXT_SHAPE_TYPES:\n            score += 5\n        else:\n            continue\n        if target_text and cand_text:\n            if target_text == cand_text:\n                score += 100\n            elif target_text in cand_text or cand_text in target_text:\n                score += 50\n        elif not target_text and not cand_text:\n            score += 20\n        if target_hash and cand_hash:\n            if target_hash == cand_hash:\n                score += 100\n        if hasattr(target_shape, 'left') and hasattr(candidate, 'left'):\n            pos_diff = abs(target_shape.left - candidate.left) + abs(target_shape.top - candidate.top)\n            if pos_diff < 100000:\n                score += 10\n            elif pos_diff < 500000:\n                score += 5\n        if score > best_score:\n            best_score = score\n            best_match = candidate\n            best_match_idx = idx\n    return (best_match, best_match_idx)\n\ndef compare_shape_fill(shape1, shape2, ctx):\n    import re\n    import xml.etree.ElementTree as ET\n    elem1_str = ET.tostring(shape1._element, encoding='unicode')\n    elem2_str = ET.tostring(shape2._element, encoding='unicode')\n    rgb1 = sorted(re.findall(r'srgbClr val=\"([A-Fa-f0-9]{6})\"', elem1_str))\n    rgb2 = sorted(re.findall(r'srgbClr val=\"([A-Fa-f0-9]{6})\"', elem2_str))\n    if rgb1 != rgb2:\n        log_mismatch(f\"{ctx}: Fill color mismatch - test={rgb1}, golden={rgb2}\")\n        return False\n    alpha1 = sorted(re.findall(r'alpha val=\"(\\d+)\"', elem1_str))\n    alpha2 = sorted(re.findall(r'alpha val=\"(\\d+)\"', elem2_str))\n    if alpha1 != alpha2:\n        pct1 = [round(100 - (int(a) / 1000), 1) for a in alpha1]\n        pct2 = [round(100 - (int(a) / 1000), 1) for a in alpha2]\n        log_mismatch(f\"{ctx}: Transparency mismatch - test={pct1}%, golden={pct2}%\")\n        return False\n    scheme1 = sorted(re.findall(r'schemeClr val=\"(\\w+)\"', elem1_str))\n    scheme2 = sorted(re.findall(r'schemeClr val=\"(\\w+)\"', elem2_str))\n    if scheme1 != scheme2:\n        log_mismatch(f\"{ctx}: Scheme color mismatch - test={scheme1}, golden={scheme2}\")\n        return False\n    return True\n\ndef compare_shape_outline(shape1, shape2, ctx):\n    if not hasattr(shape1, 'line') or not hasattr(shape2, 'line'):\n        return True\n    try:\n        line1 = shape1.line\n        line2 = shape2.line\n        if line1.dash_style != line2.dash_style:\n            log_mismatch(f\"{ctx}: Outline style mismatch - test={line1.dash_style}, golden={line2.dash_style}\")\n            return False\n        width1 = line1.width or 0\n        width2 = line2.width or 0\n        if not is_approximately_equal(width1, width2, tolerance=0.01):\n            log_mismatch(f\"{ctx}: Outline width mismatch - test={width1}, golden={width2}\")\n            return False\n        try:\n            if hasattr(line1.color, 'rgb') and hasattr(line2.color, 'rgb'):\n                if line1.color.rgb != line2.color.rgb:\n                    log_mismatch(f\"{ctx}: Outline color mismatch - test={line1.color.rgb}, golden={line2.color.rgb}\")\n                    return False\n        except:\n            pass\n    except:\n        pass\n    return True\n\ndef compare_picture_shape(shape1, shape2, ctx):\n    if not is_approximately_equal(shape1.left, shape2.left) or not is_approximately_equal(shape1.top, shape2.top):\n        log_mismatch(f\"{ctx} (PICTURE): Position mismatch - test=({shape1.left}, {shape1.top}), golden=({shape2.left}, {shape2.top})\")\n        return 0\n    if not is_approximately_equal(shape1.width, shape2.width) or not is_approximately_equal(shape1.height, shape2.height):\n        log_mismatch(f\"{ctx} (PICTURE): Dimension mismatch - test=({shape1.width}x{shape1.height}), golden=({shape2.width}x{shape2.height})\")\n        return 0\n    try:\n        hash1 = hashlib.md5(shape1.image.blob).hexdigest()\n        hash2 = hashlib.md5(shape2.image.blob).hexdigest()\n        if hash1 != hash2:\n            log_mismatch(f\"{ctx} (PICTURE): Image content mismatch\")\n            return 0\n    except Exception as e:\n        log_mismatch(f\"{ctx} (PICTURE): Image hash comparison failed - {str(e)}\")\n    if hasattr(shape1, 'line') and hasattr(shape2, 'line'):\n        line1, line2 = shape1.line, shape2.line\n        if line1.dash_style != line2.dash_style:\n            log_mismatch(f\"{ctx} (PICTURE): Border style mismatch\")\n            return 0\n        if not is_approximately_equal(line1.width or 0, line2.width or 0, tolerance=0.01):\n            log_mismatch(f\"{ctx} (PICTURE): Border width mismatch\")\n            return 0\n        try:\n            if hasattr(line1.color, 'rgb') and hasattr(line2.color, 'rgb'):\n                if line1.color.rgb != line2.color.rgb:\n                    log_mismatch(f\"{ctx} (PICTURE): Border color mismatch\")\n                    return 0\n        except:\n            pass\n    return 1\n\ndef compare_table_shape(shape1, shape2, ctx):\n    POSITION_TOLERANCE_EMU = 2000\n    if abs(shape1.left - shape2.left) > POSITION_TOLERANCE_EMU or abs(shape1.top - shape2.top) > POSITION_TOLERANCE_EMU:\n        log_mismatch(f\"{ctx} (TABLE): Position mismatch\")\n        return 0\n    if not is_approximately_equal(shape1.width, shape2.width) or not is_approximately_equal(shape1.height, shape2.height):\n        log_mismatch(f\"{ctx} (TABLE): Dimension mismatch\")\n        return 0\n    table1, table2 = shape1.table, shape2.table\n    if len(table1.rows) != len(table2.rows) or len(table1.columns) != len(table2.columns):\n        log_mismatch(f\"{ctx} (TABLE): Table size mismatch\")\n        return 0\n    for row_idx in range(len(table1.rows)):\n        for col_idx in range(len(table1.columns)):\n            cell1 = table1.cell(row_idx, col_idx)\n            cell2 = table2.cell(row_idx, col_idx)\n            cell_ctx = f\"{ctx}, Cell [{row_idx},{col_idx}]\"\n            text1 = normalize_cell_text(cell1.text)\n            text2 = normalize_cell_text(cell2.text)\n            if text1 != text2:\n                log_mismatch(f\"{cell_ctx}: Text mismatch - test='{text1}', golden='{text2}'\")\n                return 0\n            if len(cell1.text_frame.paragraphs) != len(cell2.text_frame.paragraphs):\n                log_mismatch(f\"{cell_ctx}: Paragraph count mismatch\")\n                return 0\n            for para_idx, (para1, para2) in enumerate(zip(cell1.text_frame.paragraphs, cell2.text_frame.paragraphs)):\n                if len(para1.runs) != len(para2.runs):\n                    log_mismatch(f\"{cell_ctx}, Para {para_idx}: Run count mismatch\")\n                    return 0\n                for run_idx, (run1, run2) in enumerate(zip(para1.runs, para2.runs)):\n                    run_ctx = f\"{cell_ctx}, Para {para_idx}, Run {run_idx}\"\n                    if hasattr(run1.font.color, \"rgb\") and hasattr(run2.font.color, \"rgb\"):\n                        if run1.font.color.rgb != run2.font.color.rgb:\n                            log_mismatch(f\"{run_ctx}: Font color mismatch\")\n                            return 0\n                    if not fonts_effectively_equal(run1.font.bold, run2.font.bold):\n                        log_mismatch(f\"{run_ctx}: Font bold mismatch\")\n                        return 0\n                    if not fonts_effectively_equal(run1.font.italic, run2.font.italic):\n                        log_mismatch(f\"{run_ctx}: Font italic mismatch\")\n                        return 0\n                    if run1.font.underline != run2.font.underline:\n                        if not (run1.font.underline is None and run2.font.underline is None):\n                            if (run1.font.underline is None) != (run2.font.underline is None) or (run1.font.underline is True) != (run2.font.underline is True):\n                                log_mismatch(f\"{run_ctx}: Font underline mismatch\")\n                                return 0\n    return 1\n\ndef compare_shape_geometry(shape1, shape2, ctx):\n    if not is_approximately_equal(shape1.left, shape2.left) or not is_approximately_equal(shape1.top, shape2.top) or not is_approximately_equal(shape1.width, shape2.width) or not is_approximately_equal(shape1.height, shape2.height):\n        log_mismatch(f\"{ctx}: Geometry mismatch - pos: test=({shape1.left}, {shape1.top}) vs golden=({shape2.left}, {shape2.top}), size: test=({shape1.width}x{shape1.height}) vs golden=({shape2.width}x{shape2.height})\")\n        return False\n    return True\n\ndef compare_text_shape(shape1, shape2, ctx):\n    if shape1.text.strip() != shape2.text.strip():\n        log_mismatch(f\"{ctx}: Text content mismatch\")\n        return 0\n    if len(shape1.text_frame.paragraphs) != len(shape2.text_frame.paragraphs):\n        log_mismatch(f\"{ctx}: Paragraph count mismatch\")\n        return 0\n    for para_idx, (para1, para2) in enumerate(zip(shape1.text_frame.paragraphs, shape2.text_frame.paragraphs), 1):\n        para_ctx = f\"{ctx}, Para {para_idx}\"\n        align1 = normalize_alignment(para1.alignment)\n        align2 = normalize_alignment(para2.alignment)\n        if align1 != align2:\n            log_mismatch(f\"{para_ctx}: Alignment mismatch - test={align1}, golden={align2}\")\n            return 0\n        if para1.text != para2.text:\n            log_mismatch(f\"{para_ctx}: Text mismatch\")\n            return 0\n        if para1.level != para2.level:\n            log_mismatch(f\"{para_ctx}: Indent level mismatch\")\n            return 0\n        if len(para1.runs) != len(para2.runs):\n            log_mismatch(f\"{para_ctx}: Run count mismatch\")\n            return 0\n        for run_idx, (run1, run2) in enumerate(zip(para1.runs, para2.runs), 1):\n            run_ctx = f\"{para_ctx}, Run {run_idx}\"\n            if run1.font.name != run2.font.name:\n                log_mismatch(f\"{run_ctx}: Font name mismatch - test='{run1.font.name}', golden='{run2.font.name}'\")\n                return 0\n            if run1.font.size != run2.font.size:\n                log_mismatch(f\"{run_ctx}: Font size mismatch\")\n                return 0\n            if not fonts_effectively_equal(run1.font.bold, run2.font.bold):\n                log_mismatch(f\"{run_ctx}: Font bold mismatch\")\n                return 0\n            if not fonts_effectively_equal(run1.font.italic, run2.font.italic):\n                log_mismatch(f\"{run_ctx}: Font italic mismatch\")\n                return 0\n            if hasattr(run1.font.color, \"rgb\") and hasattr(run2.font.color, \"rgb\"):\n                if run1.font.color.rgb != run2.font.color.rgb:\n                    log_mismatch(f\"{run_ctx}: Font color mismatch - test={run1.font.color.rgb}, golden={run2.font.color.rgb}\")\n                    return 0\n            if run1.font.underline != run2.font.underline:\n                if run1.font.underline is not None and run2.font.underline is not None:\n                    log_mismatch(f\"{run_ctx}: Font underline mismatch\")\n                    return 0\n                if (run1.font.underline is None and run2.font.underline is True) or (run1.font.underline is True and run2.font.underline is None):\n                    log_mismatch(f\"{run_ctx}: Font underline mismatch\")\n                    return 0\n            strike1 = run1.font._element.attrib.get('strike', 'noStrike')\n            strike2 = run2.font._element.attrib.get('strike', 'noStrike')\n            if strike1 != strike2:\n                log_mismatch(f\"{run_ctx}: Strikethrough mismatch\")\n                return 0\n            try:\n                bullets1 = extract_bullets(run1.part.blob.decode('utf-8'))\n                bullets2 = extract_bullets(run2.part.blob.decode('utf-8'))\n                if not compare_bullets(bullets1, bullets2):\n                    log_mismatch(f\"{run_ctx}: Bullets mismatch\")\n                    return 0\n            except:\n                pass\n    return 1\n\ndef compare_pptx_files(file1_path, file2_path):\n    prs1 = Presentation(file1_path)\n    prs2 = Presentation(file2_path)\n    if len(prs1.slides) != len(prs2.slides):\n        log_mismatch(f\"Slide count mismatch: test={len(prs1.slides)}, golden={len(prs2.slides)}\")\n        return 0\n    for slide_idx, (slide1, slide2) in enumerate(zip(prs1.slides, prs2.slides), 1):\n        if get_slide_background_color(slide1) != get_slide_background_color(slide2):\n            log_mismatch(f\"Slide {slide_idx}: Background color mismatch\")\n            return 0\n        notes1 = get_slide_notes(slide1).strip()\n        notes2 = get_slide_notes(slide2).strip()\n        if notes1 != notes2:\n            log_mismatch(f\"Slide {slide_idx}: Notes mismatch\")\n            return 0\n        if len(slide1.shapes) != len(slide2.shapes):\n            log_mismatch(f\"Slide {slide_idx}: Shape count mismatch - test={len(slide1.shapes)}, golden={len(slide2.shapes)}\")\n            return 0\n        test_shapes = list(slide1.shapes)\n        golden_shapes = list(slide2.shapes)\n        used_golden_indices = set()\n        for test_idx, test_shape in enumerate(test_shapes):\n            golden_shape, golden_idx = find_matching_shape(test_shape, golden_shapes, used_golden_indices)\n            if golden_shape is None:\n                test_sig = get_shape_signature(test_shape)\n                log_mismatch(f\"Slide {slide_idx}: No matching shape for test shape {test_idx + 1} (type={test_sig[0]}, text='{test_sig[1][:30]}...')\")\n                return 0\n            used_golden_indices.add(golden_idx)\n            ctx = f\"Slide {slide_idx}, Shape (test:{test_idx + 1} <-> golden:{golden_idx + 1})\"\n            shape1, shape2 = test_shape, golden_shape\n            if not compare_shape_fill(shape1, shape2, ctx):\n                return 0\n            if not compare_shape_outline(shape1, shape2, ctx):\n                return 0\n            if shape1.shape_type == MSO_SHAPE_TYPE.PICTURE:\n                if compare_picture_shape(shape1, shape2, ctx) == 0:\n                    return 0\n            if shape1.shape_type == MSO_SHAPE_TYPE.TABLE:\n                if compare_table_shape(shape1, shape2, ctx) == 0:\n                    return 0\n            if not compare_shape_geometry(shape1, shape2, ctx):\n                return 0\n            if hasattr(shape1, \"text\") and hasattr(shape2, \"text\"):\n                if compare_text_shape(shape1, shape2, ctx) == 0:\n                    return 0\n        if len(used_golden_indices) != len(golden_shapes):\n            unmatched = set(range(len(golden_shapes))) - used_golden_indices\n            log_mismatch(f\"Slide {slide_idx}: {len(unmatched)} golden shape(s) not matched\")\n            return 0\n        text_shapes1 = get_all_text_shapes(slide1)\n        text_shapes2 = get_all_text_shapes(slide2)\n        if len(text_shapes1) != len(text_shapes2):\n            log_mismatch(f\"Slide {slide_idx}: Text shape count mismatch (including groups)\")\n            return 0\n        used_golden_text_indices = set()\n        for test_idx, tshape1 in enumerate(text_shapes1):\n            tshape2, golden_text_idx = find_matching_shape(tshape1, text_shapes2, used_golden_text_indices)\n            if tshape2 is None:\n                log_mismatch(f\"Slide {slide_idx}: No matching text shape for test TextShape {test_idx + 1}\")\n                return 0\n            used_golden_text_indices.add(golden_text_idx)\n            ctx = f\"Slide {slide_idx}, TextShape (test:{test_idx + 1} <-> golden:{golden_text_idx + 1})\"\n            if not compare_shape_fill(tshape1, tshape2, ctx):\n                return 0\n            if tshape1.text.strip() != tshape2.text.strip():\n                log_mismatch(f\"{ctx}: Text mismatch\")\n                return 0\n            if len(tshape1.text_frame.paragraphs) != len(tshape2.text_frame.paragraphs):\n                log_mismatch(f\"{ctx}: Paragraph count mismatch\")\n                return 0\n            for para_idx, (para1, para2) in enumerate(zip(tshape1.text_frame.paragraphs, tshape2.text_frame.paragraphs), 1):\n                align1 = normalize_alignment(para1.alignment)\n                align2 = normalize_alignment(para2.alignment)\n                if align1 != align2:\n                    log_mismatch(f\"{ctx}, Para {para_idx}: Alignment mismatch\")\n                    return 0\n    return 1\n\ntry:\n    result = compare_pptx_files(ACTUAL_FILE_PATH, GOLDEN_FILE_PATH)\n    if result == 1:\n        print('MATCH', end='')\n    else:\n        if first_mismatch:\n            print(first_mismatch, end='')\n        else:\n            print('MISMATCH', end='')\nexcept Exception as e:\n    print(f'ERROR: {str(e)}', end='')\nEOF"
      ]
    },
    "expected": {
      "type": "rule",
      "rules": {
        "expected": "MATCH"
      }
    }
  }
}